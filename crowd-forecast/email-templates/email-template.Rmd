---
  output: 
    blastula::blastula_email
  title: "Crowd Forecast Updates"
  fig_caption: false
---

```{r echo=FALSE, message=FALSE, warning=FALSE}

knitr::opts_chunk$set(echo = FALSE, 
                      message = FALSE, 
                      warning = FALSE)


library(here)
library(scoringutils)
library(dplyr)
library(data.table)
library(covid.german.forecasts)
library(kableExtra)
```


```{r load-data, echo=FALSE, message = FALSE, warning = FALSE}
# load all data ----------------------------------------------------------------
root_dir <- here::here("crowd-forecast", "processed-forecast-data")
file_paths_forecast <- here::here(root_dir, list.files(root_dir))

prediction_data <- purrr::map_dfr(file_paths_forecast, 
                                  .f = function(x) {
                                    data <- data.table::fread(x) %>%
                                      dplyr::mutate(target_end_date = as.Date(target_end_date), 
                                                    submission_date = as.Date(submission_date), 
                                                    forecast_date = as.Date(forecast_date))
                                  }) %>%
  dplyr::mutate(target_type = ifelse(grepl("death", target), "death", "case")) %>%
  dplyr::rename(prediction = value) %>%
  dplyr::mutate(forecast_date = as.Date(submission_date)) %>%
  dplyr::rename(model = board_name) %>%
  dplyr::filter(type == "quantile", 
                location_name %in% c("Germany", "Poland")) %>%
  dplyr::select(location, location_name, forecast_date, quantile, prediction, model, target_end_date, horizon, target, target_type)

# filter forecasters such that only those are kept that have submitted forecasts
# in the last four weeks
keep_fc <- prediction_data %>%
  dplyr::filter(forecast_date > (Sys.Date() - 4 * 7)) %>%
  dplyr::pull(model) %>%
  unique()

prediction_data <- dplyr::filter(prediction_data, 
                                 model %in% keep_fc)

files <- list.files(here::here("data-raw"))
file_paths <- here::here("data-raw", files[grepl("weekly-incident", files)])
names(file_paths) <- c("case", "death")

truth_data <- purrr::map_dfr(file_paths, readr::read_csv, .id = "target_type") %>%
  dplyr::rename(true_value = value) %>%
  dplyr::mutate(target_end_date = as.Date(target_end_date)) %>%
  dplyr::arrange(location, target_type, target_end_date) %>%
  dplyr::filter(location_name %in% c("Germany", "Poland"))


data <- scoringutils::merge_pred_and_obs(prediction_data, truth_data, 
                                         join = "full")

```


### Dear `r name`,

Good to have you as a forecaster! Here is this weeks reminder and an update about what has happened lately. You're receiving this message because you gave us your email address when you registered for the [Epiforecasts Crowd Forecast App](https://cmmid-lshtm.shinyapps.io/crowd-forecast/). 

### The European Forecast Hub

On March 8th, the [European Forecast Hub](https://covid19forecasthub.eu/) will launch. We therefore have expanded our crowd forecast app which now incluedes a set of 32 countries. Given the very promising results of our forecasts in Germany and Poland, we believe the crowd forecast app will be an exciting and valuable contribution to the European Forecast Hub. For now the link to the [performance board](https://epiforecasts.io/covid.german.forecasts) stays the same, but we will update it in the near future. 

For you as a forecaster, two things changes: 

1. The **data now gets updated every Sunday at 8.30am CET** and the **submission deadline is Monday at 11pm CET (10pm UK time)**. 

2. You now have a selection of 32 countries to forecast. We are of course happy if you do submit a forecast for every country, but you may want to make your own selection of countries to forecast. By default, all 32 countries are enabled, but you may want to change that selection in the 'Account Details' Menu item in the menu on the left side of the screen. We will store your selection and only ask you to forecast the countries you want to forecast whenever you login. 


<br>

### Updates to the app

Some small updates have been made to the app. You can now see and change your user data. Simply click on 'Account Details' on the menu to the left of the screen. You can also use this to delete your email address if you don't want to receive further emails. 

We also added a new Tab where you can see your current submissisons. Currently this is just a list of targets that you have submitted successfully, but we plan to replace that with plots of your submissions soon. 

<br>

### Introduction video

In case you missed it: We created a [short video](https://www.youtube.com/watch?v=NzZkNxXFgm8) that explains how to make a forecast to help new forecasters get used to the user interface. If you like, check it out. 

<br>

### Reminder for the weekly forecasts

We **update our data every Sunady at 8.30am CET**. You can then make a forecast until **11pm CET (1opm UK time) on Monday** using our [forecast app](https://cmmid-lshtm.shinyapps.io/crowd-forecast/). We would be very happy to have a forecast from you this week!


<br>

### Forecast and Performance overview

Now, let's have a look at last weeks forecasts and performance!

In the following we put together a short overview for you. You can find more detailed information on our performance board [here](https://epiforecasts.io/covid.german.forecasts). 

*Here are the latest EpiExpert ensemble forecasts and next to them your own forecasts
if you have submitted any.*

```{r plot-forecasts, echo=FALSE, out.width="49%", fig.show="hold"}

if (weekdays(Sys.Date()) == "Monday") {
  forecast_date <- covid.german.forecasts::latest_weekday(Sys.Date() - 7)
} else {
  forecast_date <- covid.german.forecasts::latest_weekday(Sys.Date())
}


filter_truth <- list('target_end_date >= Sys.Date() - 14 * 7')
filter_forecasts <- list("model %in% 'EpiExpert-ensemble'", 
                         paste0("forecast_date == '", forecast_date, "'"))

plot_predictions(data = data, 
                 x = "target_end_date",
                 filter_truth = filter_truth, 
                 filter_forecasts = filter_forecasts,
                 facet_formula = target_type ~ location_name, 
                 facet_wrap_or_grid = "grid") + 
  ggplot2::labs(x = "Date", title = "Ensemble Forecasts") + 
  ggplot2::theme(legend.position = "bottom")

filter_truth <- list('target_end_date >= Sys.Date() - 14 * 7')
filter_forecasts <- list(paste0("model %in% '", board_name, "'"), 
                         paste0("forecast_date == '", forecast_date, "'"))

p <- plot_predictions(data = data, 
                 x = "target_end_date",
                 filter_truth = filter_truth, 
                 filter_forecasts = filter_forecasts,
                 facet_formula = target_type ~ location_name, 
                 facet_wrap_or_grid = "grid") 
if (!is.null(p)) {
  p <- p + 
  ggplot2::labs(x = "Date", title = "Your Forecasts") + 
  ggplot2::theme(legend.position = "bottom")
  print(p)
}


```

<br>

*Here is the list with the current top 5 forecasters (based on the last 5 weeks): *

```{r rank-table, echo=FALSE, fig.align="center"}
cut_off <- covid.german.forecasts::latest_weekday(Sys.Date()) - 5 * 7
df <- data %>%
  filter(forecast_date >= cut_off)
  
table <- eval_forecasts(data, summarise_by = c("model"), 
                        compute_relative_skill = TRUE)

table %>%
    arrange(relative_skill) %>%
    dplyr::select(-scaled_rel_skill) %>%
    mutate_if(is.numeric, round, 2) %>%
    dplyr::rename(wis = interval_score,
                  underpred = underprediction,
                  overpred = overprediction,
                  cvrage_dev = coverage_deviation,
                  rel_skill = relative_skill) %>%
  select(model, rel_skill) %>%
  head(5) %>%
  knitr::kable(format = "html") %>% 
  kable_styling(bootstrap_options = "striped", full_width = F)



```

<br>

*And here is a plot with the rank by date and target of all active forecasters over time:*

```{r rank-over-time, echo=FALSE, fig.align = "center", fig.width=10, fig.height=8, out.width="80%"}
scores <- scoringutils::eval_forecasts(data,
                                         summarise_by = c("model", 
                                                          "location_name", 
                                                          "target_type",
                                                          "forecast_date"), 
                                       compute_relative_skill = FALSE)

ranked_scores <- scores %>%
  dplyr::mutate(forecast_date = as.Date(forecast_date)) %>%
  dplyr::group_by(forecast_date, location_name, target_type) %>%
  dplyr::mutate(num_forecasts = dplyr::n(), 
                rank = rank(interval_score, ties.method = "average",
                                           na.last = NA), 
                standard_rank = round((1 - (rank - 1) / (num_forecasts - 1)) * 100)) %>%
  dplyr::ungroup()

plot <- score_heatmap(ranked_scores, metric = "rank", 
                      x = "forecast_date",
                      facet_wrap_or_grid = "grid",
                      facet_formula = location_name ~ target_type) + 
  ggplot2::theme(legend.position = "bottom") +
    ggplot2::scale_fill_gradient(low = "white", high = "coral")

print(plot)
```

<br>

If you have any further questions or feedback, please don't hesitate to reach out. You can drop us an email or submit an issue to our [github repo](https://github.com/epiforecasts/covid.german.forecasts)

Thank you very much for your support and participation. We very much appreciate it!

Best wishes, 

Nikos for the Epiforecasts team

<br>

PS: If you don't want to receive future emails simply write me a quick message or go to the app and click on 'Account Details' in the menu to the left of the screen. You can simply delete your email address there. 

