---
title: "Analysis UK Crowd Forecasting Challenge"
output: 
  bookdown::html_document2:
    theme: journal
    number_sections: true
    self_contained: true
  # bookdown::pdf_document2:
  #   number_sections: true
---



This is an analysis of forecasts made by participants of the UK COVID-19 Crowd Forecasting Challenge. Over the course of 13 weeks (from May 24 2021 to August 16 2021) participants submitted forecasts using the [crowdforecastr prediction platform](https://crowdforecastr.org). 

These forecasts were aggregated by calculating the median prediction of all forecasts. These aggregated forecasts (later denoted as "epiforecasts-EpiExpert" or "Median ensemble") were submitted to the [European Forecast Hub](https://covid19forecasthub.eu/). 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, out.width = "100%")
library(scoringutils)
library(magrittr)
library(dplyr)
library(ggplot2)
library(covid.ecdc.forecasts)
library(kableExtra)
library(stringr)
library(patchwork)

make_table <- function(x, caption = "") {
  x %>%
    rename_all(gsub, pattern = "_", replacement = " ") %>%
    rename_all(str_to_sentence) %>%
    mutate_if(is.numeric, round, 2) %>%
    kable(caption = caption) %>%
    kable_styling()
}

model_colors <- 
  c(`epiforecasts-EpiExpert` = "#E41A1C", 
    `Median ensemble` = "#E41A1C", 
    "anonymous_Stingray" = "#003C30", #"#E7298A", 
    "seb" = "#377EB8",  
    "aen" = "#4DAF4A", 
    "Trebuchet01" = "#984EA3", 
    "habakuk (Rt)" = "#FF7F00", 
    `epiforecasts-EpiExpert_direct` = "#5AB4AC", #FFFF33", 
    `epiforecasts-EpiExpert_Rt` = "#A65628", 
    `EuroCOVIDhub-baseline` = "#F781BF", 
    `EuroCOVIDhub-ensemble` = "#1B9E77", 
    `Individual participant` = "grey80", 
    "Median score" = "blue") %>%
  sort()

expert_colours <- c("Expert" = "red", 
                    "Non-expert" = "black", 
                    "Unknown" = "grey50")

subset_colors <- function(model_names) {
  model_colors[names(model_colors) %in% model_names]
}


scale_fn <- function(x) {
  ifelse(x >= 1000000, 
         paste0(x / 1000000, "m"), 
         ifelse(x >= 5000,
                paste0(x / 1000, "k"),
                x))
}

```

```{r}
score_forecasts <- function(data) {
  eval_forecasts(data, 
                 summarise_by = c("model", "forecast_date", "target_type", "expert"), 
                 by = c("forecast_date", "target_type", "horizon", "model", "expert"))[]
}

scores_participants <- 
  score_forecasts(log_data[model %in% models[["participants"]]])
scores_all <- score_forecasts(log_data)

scores_participants_notlog <- 
  score_forecasts(data[model %in% models[["participants"]]])
scores_all_notlog <- score_forecasts(data)

```

```{r}
# assign median score per forecast date if someone missed a forecast date
complete_set <- expand.grid(forecast_date = study_dates$forecast_dates, 
                            model = models[["participants"]], 
                            target_type = c("Cases", "Deaths"))

add_median_to_scores <- function(df) {
  df %>%
    group_by(forecast_date, target_type) %>%
    mutate(interval_score = ifelse(is.na(interval_score), 
                                   median(interval_score, na.rm = TRUE), 
                                   interval_score)) %>%
    ungroup()
}

tournament_scores <- scores_participants %>% 
  full_join(complete_set) %>%
  add_median_to_scores() %>%
  group_by(model) %>%
  summarise(interval_score = sum(interval_score)) %>%
  arrange(interval_score) 

top5_forecasters <- tournament_scores %>%
  pull(model) %>%
  head(5)

```


# Prediction targets and observed values

Participants were asked to make one to four week ahead predictions of the weekly number of reported cases and deaths from COVID-19 in the UK. Figure \@ref(fig:data-viz) shows a visualisation of daily and weekly observed cases and deaths. 

```{r}
filter_truth <- function(df) {
  df %>%
    filter(target_end_date >= "2021-04-01", 
           target_end_date <= "2021-09-11") %>%
    arrange(target_end_date) %>%
    mutate(target_type = ifelse(target_type == "case", 
                                "Cases", "Deaths"))
}

dailydf <- filter_truth(dailytruth_data)
weeklydf <- filter_truth(truth)
```

```{r}
caption <- "Visualisation of daily (bars) and weekly (line) reported numbers."
```

```{r data-viz, fig.cap = caption}
dailydf %>%
  ggplot(aes(y = true_value, x = target_end_date)) + 
  geom_col(fill = "lightsteelblue", color = "white") + 
  geom_line(data = weeklydf, aes(y = true_value / 7)) + 
  geom_point(data = weeklydf, aes(y = true_value / 7), size = 0.6) +
  labs(y = "Observed values", x = "Date") + 
  facet_wrap(~ target_type, ncol = 1, scale = "free") + 
  theme_minimal() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        panel.spacing = unit(3, "lines"))
  
```


<br>
<br>

# Visualisation of forecasts

Figure \@ref(fig:viz-forecast-all) shows the median predictions of all participants as well as the crowd ensemble. We can see that there is considerable disagreement between individual forecasters on most forecast dates. 

```{r}
caption <- "Median forecasts from all participants"
```

```{r viz-forecast-all, fig.cap=caption}
models_included <- c("epiforecasts-EpiExpert", models$participants)
cols <- subset_colors(c("epiforecasts-EpiExpert", "Individual participant"))

zero_horizon <- weeklydf %>%
  mutate(forecast_date = target_end_date + 2, 
         horizon = 0, 
         prediction = true_value, 
         quantile = 0.5) %>%
  full_join(data.frame(model = models_included), by = character())


plot_df <- data %>%
  filter(model %in% c(models_included),
         horizon %in% c(1, 2, 3, 4)) %>%
  full_join(zero_horizon) %>%
  tidyr::pivot_wider(values_from = "prediction", names_from = "quantile") %>%
  mutate(model_unique = model, 
         model = ifelse(model %in% "epiforecasts-EpiExpert", model, "Individual participant")) 
  
plot_df %>%  
  ggplot(aes(x = target_end_date)) + 
  geom_line(aes(y = `0.5`, group = interaction(forecast_date, model_unique), color = model), 
            alpha = 0.8, size = 0.2) +
  geom_line(data = filter(plot_df, model == "epiforecasts-EpiExpert"), 
            aes(y = `0.5`, color = model, group = forecast_date), 
            size = 0.5) + 
  scale_color_manual(values = cols, name = "Forecast") +
  facet_wrap(~ target_type, ncol = 1, scale = "free") + 
  theme_minimal() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        panel.spacing = unit(3, "lines")) +  
  geom_line(data = weeklydf, aes(y = true_value)) + 
  geom_point(data = weeklydf, aes(y = true_value), size = 0.7) + 
  scale_y_continuous(labels = scale_fn) + 
  labs(y = "Median forecast and observed values", x = "Date") + 
  theme(legend.position = "bottom")
```


Figure \@ref(fig:viz-forecast-ensemble) compares median predictions from the crowd ensemble against the Hub ensemble. The two ensembles are in closer agreements than the individual crowd forecasters. 

```{r}
caption <- "Visualsation of forecasts from the crowd ensemble and the Hub ensemble. Lines show the median forecast one to four weeks into the future for a given forecast date."
```


```{r viz-forecast-ensemble, fig.cap=caption}

truth <- weeklydf %>%
  filter(target_end_date >= study_dates$plot_dates[1],
         target_end_date <= study_dates$plot_dates[2])

models_included <- c("EuroCOVIDhub-ensemble", "epiforecasts-EpiExpert")

zero_horizon <- weeklydf %>%
  mutate(forecast_date = target_end_date + 2, 
         horizon = 0, 
         prediction = true_value, 
         quantile = 0.5) %>%
  full_join(data.frame(model = models_included), by = character())


data %>%
  filter(model %in% models_included,
         horizon %in% c(1, 2, 3, 4)) %>%
  full_join(zero_horizon) %>%
  tidyr::pivot_wider(values_from = "prediction", names_from = "quantile") %>%
  ggplot(aes(x = target_end_date)) + 
  geom_line(aes(y = `0.5`, group = interaction(forecast_date, model), color = model), 
            alpha = 0.4, size = 0.5) + 
  scale_color_manual(values = subset_colors(models_included), name = "Forecast") +
  facet_wrap(~ target_type, ncol = 1, scale = "free") + 
  theme_minimal() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        panel.spacing = unit(3, "lines")) +  
  geom_line(data = truth, aes(y = true_value)) + 
  geom_point(data = truth, aes(y = true_value), size = 0.7) + 
  scale_y_continuous(labels = scale_fn) + 
  labs(y = "Median forecast and observed values", x = "Date") + 
  theme(legend.position = "bottom")
```


Figure \@ref(fig:viz-forecast-ensemble-bars) illustrates uncertainty around the predictions made by the crowd ensemble. For all two week ahead forecasts, the 50% (darker) and 95% (lighter) prediction intervals are shown. We see that observed values are outside of the prediction intervals regularly. 


```{r}
caption <- "Visualisation of 2 week ahead forecasts of the crowd forecast ensemble with 50% prediction intervals (dark) and 95% prediction intervals (light)."
```


```{r viz-forecast-ensemble-bars, fig.cap=caption}
models_included <- c("epiforecasts-EpiExpert")

zero_horizon <- weeklydf %>%
  mutate(forecast_date = target_end_date + 2, 
         horizon = 0, 
         prediction = true_value, 
         quantile = 0.5)

data %>%
  filter(model %in% models_included,
         horizon %in% c(2)) %>%
  full_join(zero_horizon) %>%
  tidyr::pivot_wider(values_from = "prediction", names_from = "quantile") %>%
  ggplot(aes(x = target_end_date)) + 
  geom_linerange(aes(ymin = `0.025`, ymax = `0.975`, color = model), size = 1.5, 
                 alpha = 0.3) + 
  geom_linerange(aes(ymin = `0.25`, ymax = `0.75`, color = model), size = 1.5, 
                 alpha = 0.4) + 
  scale_color_manual(values = subset_colors(models_included), name = "Forecast") +
  facet_wrap(~ target_type, ncol = 1, scale = "free") + 
  theme_minimal() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        panel.spacing = unit(3, "lines")) +  
  geom_line(data = truth, aes(y = true_value)) + 
  geom_point(data = truth, aes(y = true_value), size = 0.7) + 
  scale_y_continuous(labels = scale_fn) + 
  labs(y = "Median forecast and observed values", x = "Date") + 
  theme(legend.position = "bottom")
```


<br>
<br>

```{r}

```






# Forecast evaluation

Forecasts were evaluated using the Weighted interval score (WIS). This score is negatively oriented, meaning that a lower score is better. You can think of the weighted interval score as a penalty for being less than perfect. 

The weighted interval score is the sum of three components (i.e. three different types of penalties): Over-prediction, under-prediction and dispersion. Over-prediction and under-prediction are penalties that occur if the true observed value falls outside of the range of values deemed plausible by a forecast. If a forecast is very uncertain, then the range of plausible values is larger and it is less likely to get penalties for over- and under-prediction. The dispersion term on the other hand penalises a forecast for being overly uncertain.

To make forecasts of deaths and reported infections more comparable, we took the logarithm of all forecasts as well as the logarithm of the “ground truth data” and then calculated the weighted interval score using these.

This is different from the methodology used by the [European Forecast Hub](https://covid19forecasthub.eu/), which does not take the logarithm of forecasts and observed values. Taking the logarithm means that forecasts are scored in relative terms rather than absolute terms. On the natural scale it is important whether a forecast is e.g. 10 off or 1000, while on the logarithmic scale we score whether a forecast is 5% or 10% off - regardless of the absolute values. This may make more sense for a pandemic anyway where infections spread exponentially. It also allowed us to combine death forecasts and case forecasts and compute a single score to rank forecasters. 

If a forecaster did not submit a forecast for a given forecast date, they were assigned the median score of all participants who submitted a forecast on that day. 


## Leaderboard

Table \@ref(tab:leaderboard) shows the overall leaderboard with scores summarised over different forecast dates, targets and horizons. In order to determine the winner of the forecasting competition, scores were averaged to obtain a single performance metric. However, this metric hides considerable variation in performance as will be explored in the following sections. Averaging across different forecast horizons also deviates from current Forecast Hub practices, as an average across different horizons does not lend itself to any meaningful interpretation. 

```{r}
caption <- "Official leaderboard with performance summarised over all forecasts across all targets and horizons. Scores summarised across different targets and horizons were used to determine the winner of the competition."
```


```{r leaderboard}
tournament_scores %>%
  rename(Score = interval_score, 
         Forecaster = model) %>%
  mutate(Ranking = 1:nrow(tournament_scores)) %>%
  select(Ranking, Forecaster, Score) %>%
  head(10) %>%
  make_table(caption = caption) 
```

<br>

## Individual vs. ensemble performance over time

Forecasts from individual participants were aggregated using a median. As can be seen in Figure \@ref(fig:indiv-forecasts-time), the median ensemble generally tended to perform better than the majority of individual forecasters (espcially for death forecasts). 

```{r}
caption <- "Visualisation of individual participants' scores (grey) together with scores from the median ensemble of all forecasts (red) submitted to the European Forecast Hub. Scores per forecast date in this Figure are averaged across all forecast horizons (one to four weeks ahead) and are likely dominated by forecasts for longer horizons."
```

```{r indiv-forecasts-time, fig.cap=caption}

models_included <- c(models$participants, "epiforecasts-EpiExpert")

df <- scores_all %>%
  filter(model %in% models_included) %>%
  mutate(Forecaster = ifelse(model %in% models$participants, 
                     "Individual participant", "Median ensemble")) 

cols <- model_colors[names(model_colors) %in% c("Individual participant", 
                                                "Median ensemble")]
df %>%
  arrange(desc(Forecaster)) %>%
  ggplot(aes(y = interval_score, x = forecast_date, 
             colour = Forecaster, 
             group = model)) + 
  geom_line(aes(y = interval_score)) + 
  geom_point(size = 0.4) + 
  geom_line(data = filter(df, Forecaster == "Median ensemble"), 
            #color = "red", 
            size = 1.1) + 
  scale_color_manual(values=cols) + 
  theme_minimal() +
  theme(legend.position = "bottom") + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        panel.spacing = unit(3, "lines")) + 
  labs(y = "Combined interval score", x = "Forecast date") + 
  facet_wrap(~target_type, scale = "free", ncol = 1)
```

<br>


Another interesting question is whether individual participants were able to beat the ensemble of all participant forecasts. We can see in Figure \@ref(fig:top5-comparison) that the top five forecasters often performed better than the ensemble, but not always. Espeically for deaths it seems like forecasters struggled to beat the ensemble consistently. 

```{r}
caption <- "Scores for the top five forecasters and the median ensemble (in red) across different forecast dates. Scores are summarised across all forecast horizons."
```


```{r, top5-comparison, fig.cap=caption}

models_included <- c(top5_forecasters, "epiforecasts-EpiExpert")
df <- scores_all %>%
  filter(model %in% models_included) %>%
  arrange(interval_score) 

cols <- model_colors[names(model_colors) %in% models_included]

df %>%
  filter(model %in% c(top5_forecasters)) %>%
  ggplot(aes(y = interval_score, x = forecast_date, 
             colour = model, 
             group = model)) + 
  geom_line(aes(y = interval_score)) + 
  geom_point(size = 0.8) + 
  geom_line(data = filter(df, model == "epiforecasts-EpiExpert"),
            size = 1.1) + 
  theme_minimal() +
  scale_color_manual(values = cols) + 
  theme(legend.position = "bottom") + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        panel.spacing = unit(3, "lines")) + 
  labs(y = "Combined interval score", x = "Forecast date") + 
  facet_wrap(~target_type, scale = "free", ncol = 1)

```


<br>

Or whether they were able to be better than the median forecaster each forecast date. It is interesting to see that even the top forecasters are not consistently better than the median forecaster, as is shown in Figure \@ref(fig:top5-comparison-median)

```{r}
caption <- "Scores for the top five forecasters, median score from all other participants (in blue) and score of the median ensemble (in red) across different forecast dates. Scores are summarised across all forecast horizons."
```


```{r, top5-comparison-median, fig.cap=caption}
models_included <- c(top5_forecasters, "epiforecasts-EpiExpert")
df <- scores_all %>%
  filter(model %in% models_included) %>%
  arrange(interval_score) 

med <- scores_all %>%
  filter(model %in% models$participants) %>%
  group_by(forecast_date, target_type) %>%
  summarise(interval_score = median(interval_score)) %>%
  mutate(model = "Median score")

cols <- model_colors[names(model_colors) %in% c(models_included, 
                                                "Median score")]

df %>%
  filter(model != "epiforecasts-EpiExpert") %>%
  ggplot(aes(y = interval_score, x = forecast_date, 
             colour = model, 
             group = model)) + 
  geom_line(aes(y = interval_score)) + 
  geom_point(size = 0.8) + 
  geom_line(data = med,
            size = 1.1) + 
  geom_line(data = filter(df, model == "epiforecasts-EpiExpert"),
            size = 1.1) + 
  theme_minimal() +
  scale_color_manual(values = cols, name = "Forecaster") + 
  theme(legend.position = "bottom") + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        panel.spacing = unit(3, "lines")) + 
  labs(y = "Combined interval score", x = "Forecast date") + 
  facet_wrap(~target_type, scale = "free", ncol = 1)

```

<br>
<br>


## Forecast performance and participant characteristics

Figure \@ref(fig:performance-number-forecasts) shows how well different forecasters did as a function of the number of forecasts they submitted. Overall there doesn't seem to be a strong effect. More regular forecasters maybe did slightly better in this competition on deaths, but the results are inconclusive.   

```{r}
caption <- "Mean weighted interval score vs. the number of forecasts made by any individual forecaster"
```

```{r performance-number-forecasts, fig.cap=caption}

n_forecasts <- data %>%
  filter(!is.na(forecast_date)) %>%
  group_by(model) %>%
  summarise(n_forecasts = length(unique(forecast_date))) %>%
  arrange(-n_forecasts) %>%
  filter(!grepl("epiforecasts", model), 
         !grepl("EuroCOVIDhub", model)) 

scores_participants %>%
  group_by(model, target_type, expert) %>%
  summarise(score = mean(interval_score)) %>%
  full_join(n_forecasts) %>%
  ggplot(aes(y = score, x = n_forecasts)) + 
  geom_point(aes(color = expert)) + 
  geom_smooth() + 
  theme_minimal() + 
  scale_color_manual(values = expert_colours, name = "Expert status") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        panel.spacing = unit(3, "lines")) + 
  labs(y = "Weighted interval score", x = "Number of forecasts") + 
  facet_wrap(~target_type, scale = "free", ncol = 1) + 
  theme(legend.position = "bottom")
  
```


We are also interested in whether self-identified 'experts' performed better than 'non-experts'. As Figure \@ref(fig:performance-expert) suggests, experts may not have a clear edge over non-experts. On the contrary, in this competition it seemed experts performed slightly worse than non-experts. Note that the distinction between 'expert' and 'non-expert' is by no means clear, as there are no fixed criteria for 'experts' and 'non-experts' and participants were asked to choose what they felt most appropriate. 

```{r}
caption <- "Distribution of weighted interval scores depending on whether or not participants self-identified as an 'expert'."
```


```{r performance-expert, fig.cap = caption}

scores_participants %>%
  group_by(model, target_type, expert) %>%
  summarise(score = mean(interval_score)) %>%
  ggplot(aes(y = score, x = expert)) + 
  geom_violin(fill = "grey90", alpha = 0.6, color = NA) + 
  geom_jitter(width = 0.1, size = 0.8, alpha = 0.8, color = "grey40") + 
  geom_boxplot(alpha = 0.7, outlier.shape = NA) + 
  theme_minimal() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        panel.spacing = unit(3, "lines")) + 
  labs(y = "Weighted interval score", x = "Expert status") + 
  facet_wrap(~target_type, scale = "free", ncol = 1)

```



```{r}
caption <- "Scores for 'experts' and 'non-experts' over time. Thick line is the mean score. "
```

```{r performance-expert2, fig.cap = caption}
df <- scores_all %>%
  filter(model %in% models$participants, 
         expert != "Unknown") 

mean_perf <- df %>%
  group_by(expert, forecast_date) %>%
  summarise(interval_score = mean(interval_score))

df %>%
  ggplot(aes(y = interval_score, x = forecast_date, 
             colour = expert)) + 
  geom_line(aes(y = interval_score, group = model), size = 0.1) + 
  geom_point(size = 0.4) + 
  geom_line(data = mean_perf,
            size = 1.1) +
  scale_color_manual(values=expert_colours, name = "Expert status") + 
  theme_minimal() +
  theme(legend.position = "bottom") + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        panel.spacing = unit(3, "lines")) + 
  labs(y = "Combined interval score", x = "Forecast date") + 
  facet_wrap(~target_type, scale = "free", ncol = 1)
```





## Comparison against the Forecast Hub

Let's have a look at how the crowd forecast ensemble performed against the overall Forecast Hub. 

```{r}
caption <- 'Visualisation of scores for the ensemble of all forecasts from participants in the UK Crowd Forecasting Challenge ("epiforecasts-EpiExpert") against the ensemble of all forecasts from the European Forecast Hub (including our own forecasts) and the Forecast Hub baseline model. Scores are averaged across all forecast horizons.'
```


```{r comparison-hub-ensemble, fig.cap=caption}
models_to_compare <- c("epiforecasts-EpiExpert", 
                      "EuroCOVIDhub-baseline", 
                      "EuroCOVIDhub-ensemble")

cols <- subset_colors(models_to_compare)

scores_all %>%
  filter(model %in% models_to_compare) %>%
  ggplot(aes(y = interval_score, x = forecast_date, 
             colour = model, 
             group = model)) + 
  geom_line(aes(y = interval_score)) + 
  geom_point(size = 0.4) + 
  theme_minimal() +
  scale_color_manual(values = cols, name = "Forecasting model") + 
  theme(legend.position = "bottom") + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) + 
  labs(y = "Combined interval score", x = "Forecast date") + 
  facet_wrap(~ target_type, ncol = 1, scale = "free")
```

<br>

Table \@ref(tab:scores-hub-comparison) includes the numeric scores achieved by the crowd forecast ensemble, the Hub-ensemble and the Hub-baseline model. 

```{r}
caption <- "Summary of scores achieved by the crowd forecast ensemble, the Hub-ensemble and the Hub-baseline model. Scores were averaged across all forecast dates and forecast horizons."
```


```{r scores-hub-comparison}
scores_all %>%
  filter(model %in% models_to_compare) %>%  
  group_by(model, target_type) %>%
  summarise(score = sum(interval_score)) %>%
  arrange(target_type, score) %>%
  make_table(caption = caption) 

```

<br>
<br>



## Comparison of the different EpiExpert forecasts

Users could submit two different forecasts. One was a direct forecast of cases and deaths. The median ensemble of these direct forecasts is called "EpiExpert_direct". The other one was a forecast of $R_t$, the effective reproduction number. This $R_t$ forecast was then mapped to cases and deaths using the so-called renewal equation, which models future cases as a weighted sum of past cases times $R_t$. The median ensemble that uses only these forecasts is called "EpiExpert_Rt". The "EpiExpert" ensemble is a median ensemble that used both regular as well as $R_t$ forecasts. 

Figure \@ref(fig:ensemble-variants) shows scores for these three ensemble types over time. 

```{r}
caption <- "Scores across time for the different crowd forecast ensembles. epiforecasts-EpiExpert_direct includes only direct case and death forecasts, epiforecasts-EpiExpert_Rt includes only forecasts made through the Rt app and epiforecasts-EpiExpert includes all forecasts. Scores are average scores across all forecast horizons."
```


```{r ensemble-variants, fig.cap = caption}

models_included <- models$`Hub-submissions`[grepl("epi", models$`Hub-submissions`)]

cols <- subset_colors(model_names = models_included)

scores_all %>%
  filter(grepl("epiforecasts", model)) %>%
  ggplot(aes(y = interval_score, x = forecast_date, 
             colour = model, 
             group = model)) + 
  geom_line(aes(y = interval_score)) + 
  geom_point(size = 0.4) + 
  theme_minimal() +
  scale_color_manual(values = cols, name = "Ensemble variant") + 
  theme(legend.position = "bottom") + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        panel.spacing = unit(3, "lines")) + 
  labs(y = "Combined interval score", x = "Forecast date") + 
  facet_wrap(~target_type, scale = "free", ncol = 1)
```

<br>

Summarised scores for the different versions of the crowd forecast ensemble are given in \@ref(tab:scores-ensemble-variants). 

```{r}
caption <- "Summarised scores for the three variants of the crowd forecast ensemble."
```

```{r scores-ensemble-variants}
scores_all %>%
  filter(grepl("epiforecasts", model)) %>%
  group_by(model, target_type) %>%
  summarise(score = sum(interval_score)) %>%
  arrange(target_type, score) %>%
  make_table(caption = caption) 
```

<br>
<br>







# Number of available forecasts

```{r}
n_forecasts <- data %>%
  filter(!is.na(forecast_date)) %>%
  group_by(model) %>%
  summarise(n_forecasts = length(unique(forecast_date))) %>%
  arrange(-n_forecasts) %>%
  filter(!grepl("epiforecasts", model), 
         !grepl("EuroCOVIDhub", model)) 
```

Table \@ref(tab:top-active) shows the ten most active forecasters. The average number of forecasts per participant was 2.74, while most participants dropped out after their first forecast (Table \@ref(tab:summary-active)). Only two participants submitted a forecast for all thirteen forecast dates. 

```{r}
caption <- "Ten most active forecasters by the number of forecast dates on which a participants made a forecast"
```

```{r top-active}
n_forecasts %>% 
  head(10) %>%
  make_table(caption = caption)
```


```{r summary-active}
n_forecasts %>%
  summarise(max = max(n_forecasts), 
            min = min(n_forecasts), 
            mean = mean(n_forecasts), 
            median = median(n_forecasts)) %>%
  make_table(caption = "Summary of the number of forecasts per participant.")
```


```{r}
caption <- "Distribution of the number of forecasts made by any individual participant."
```


```{r number_forecasters, fig.cap=caption}
n_forecasts %>%
  mutate(n_forecasts = as.factor(n_forecasts)) %>%
  ggplot(aes(y = n_forecasts)) +
  geom_histogram(stat = "count") + 
  theme_minimal() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) + 
  labs(y = "Number of forecasts by a single forecaster", x = "Frequency")
```

On average, 21.9 forecasts were submitted each week, with a minimum of 10 and a maximum of 57 (Table \@ref(tab:summary-freq-time)). The distribution of the number of forecasters over time is shown in Figure \@ref(fig:distr-freq-time).

```{r}
n_forecasts <- data %>%
  filter(!is.na(forecast_date)) %>%
  filter(!grepl("epiforecasts", model), 
         !grepl("EuroCOVIDhub", model)) %>%
  group_by(forecast_date) %>%
  summarise(n_forecasts = length(unique(model))) %>%
  arrange(forecast_date)
```

```{r summary-freq-time}
n_forecasts %>%
  summarise(max = max(n_forecasts), 
            min = min(n_forecasts), 
            mean = mean(n_forecasts), 
            median = median(n_forecasts)) %>%
  make_table(caption = "Summary - number of forecasts available per forecast week")
```

```{r distr-freq-time, fig.cap="Distribution of the number of available forecasts per forecast week"}
n_forecasts %>%
  ggplot(aes(y = n_forecasts, x = forecast_date)) + 
  geom_bar(stat = "identity") + 
  theme_minimal() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) + 
  labs(y = "Number of forecasts", x = "Forecast date")
```




# Sensitivity analysis

Rankings between different models change depending on how you evaluate forecasts. For example, if you score on an absolute, rather than a logarithmic scale, results change. On the natural scale, it matters how far off a forecast is in absolute, rather than in relative terms. This implies that scores depend on the order of magnitude of the target one tries to forecast. For example, it is very easy to miss reported cases by 1000, whereas for deaths errors will rather be in the tens or hundreds. 

If reported on the natural scale, the crowd forecasts no longer outperform the Hub ensemble, as can be seen in Figure \@ref(fig:comparison-hub-ensemble-natural) and in Table \@ref(tab:scores-hub-comparison-not-log). Crowd forecasts showed worse performance than the Hub ensemble around the peak of cases in July, where cases were highest, which results in a stronger penalty if scored on the natural rather than the log scale. 

```{r}
caption <- 'Visualisation of scores for the ensemble of all forecasts from participants in the UK Crowd Forecasting Challenge ("epiforecasts-EpiExpert") against the ensemble of all forecasts from the European Forecast Hub (including our own forecasts) and the Forecast Hub baseline model. Scores were calculated on the natural scale and averaged across all forecast horizons.' 
```

```{r comparison-hub-ensemble-natural, fig.cap=caption}
models_to_compare <- c("epiforecasts-EpiExpert", 
                      "EuroCOVIDhub-baseline", 
                      "EuroCOVIDhub-ensemble")

cols <- subset_colors(models_to_compare)

scores_all_notlog %>%
  filter(model %in% models_to_compare) %>%
  ggplot(aes(y = interval_score, x = forecast_date, 
             colour = model, 
             group = model)) + 
  geom_line(aes(y = interval_score)) + 
  geom_point(size = 0.4) + 
  theme_minimal() +
  scale_color_manual(values = cols, name = "Forecasting model") + 
  theme(legend.position = "bottom") + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) + 
  labs(y = "Combined interval score", x = "Forecast date") + 
  facet_wrap(~ target_type, ncol = 1, scale = "free")
```

<br>

```{r}
caption <- "Summary of scores achieved by the crowd forecast ensemble, the Hub-ensemble and the Hub-baseline model. Scores were calculated on the natural scale and averaged across all forecast dates and forecast horizons."
```


```{r scores-hub-comparison-not-log}
scores_all_notlog %>%
  filter(model %in% models_to_compare) %>%  
  group_by(model, target_type) %>%
  summarise(score = sum(interval_score)) %>%
  arrange(target_type, score) %>%
  make_table(caption = caption) 

```

<br>
<br>




<!-- ## Rank distribution -->

```{r}
# scores %>%
#   group_by(forecast_date) %>%
#   summarise(median = median(interval_score)) %>%
#   mutate(sum = sum(median))
```










































